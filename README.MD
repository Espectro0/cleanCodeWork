## Taller Principios SOLID y GRASP

Taller realizado bajo un codigo proporcionado por el docente, identificando los problemas de dise√±o y aplicando los principios SOLID y GRASP para mejorar la calidad del c√≥digo. Proponiendo una soluci√≥n m√°s robusta y mantenible de acuerdo a lo visto en clase, presentando diagrama UML y una explicaci√≥n de los cambios realizados.

### [Ejercicio 1:](https://github.com/juliandhoyos14/EjerciciosPOO/blob/master/src/main/java/org/tallerprincipios/ejercicio1/sinaplicar/Notificador.java) Sistema de Notificaciones

* ¬øQu√© principio SOLID no se est√° cumpliendo? ¬øPor qu√©?

‚ö†Ô∏è El sistema anteriormente implementado no cumpl√≠a con los principios:

- SRP: La clase hace varias cosas al mismo tiempo, decide que tipo de notifiaci√≥n enviar y enviaba la notificaci√≥n por cada uno de los tipos.
- OCP: Cada vez que se quiere agregar un nuevo tipo de notificaci√≥n, se debe modificar la clase notificaci√≥n.
- DIP: El notificador depende directamente de los detalles que se tienen en las clases, y no existe una abstracci√≥n como lo puede hacer una interfaz.

* ¬øC√≥mo aplicar√≠a el principio Open/Closed para mejorar este dise√±o?

üí° Para lograr tener una mejor estructura en el codigo, y evitar dependencias directas, se crea una interfaz notificaci√≥n y las clases que lo implementan seg√∫n este mismo.

Ubicaci√≥n: `src/Ejercicio1/`

![Diagrama UML 1](./src/Ejercicio1/Ejercicio1.svg)

### [Ejercicio 2:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio2/sinaplicar) Gesti√≥n de Empleados

* ¬øQu√© principio GRASP prodr√≠a aplicarse aqu√≠ para mejorarse el dise√±o?

üí° El principio aplicado fue el polimorfismo, ya que nos permite crear una clase padre para asignar los comportamientos a las subclases que pueden ser implementadas, permitiendo en un futuro agregar m√°s tipos de empleados.

* ¬øCom√≥ se relaciona esta soluci√≥n con el principio Liskov Substitution?

‚ùì La relaci√≥n es que al implementar una clase abstracta o clase padre, se supone que al modificar alg√∫n tipo de empleado en espec√≠fico no tendr√≠a porque alterar cualquiera de las otras subclases o la clase padre del c√≥digo.

Ubicaci√≥n: `src/Ejercicio2/`

![Diagrama UML 2](./src/Ejercicio2/Ejercicio2.svg)

### [Ejercicio 3:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio3/sinaplicar) El trabajador todero

* ¬øQu√© problemas ve en el dise√±o original?

‚ö†Ô∏è El trabajador todero tiene muchas responsabilidades diferentes en una misma clase, lo que no permite tener una unica resposabilidad por clase y mucho menos un prop√≥sito claro, objetivamente si se busca agregar m√°s trabajos para este trabajador todero, llegar√≠a a ser complejo de mantener.

* Proponer una soluci√≥n aplicando el principio de responsabilidad √∫nica (SRP) y high cohesion.

üí° Dividir cada trabajo por clase, actualmente solo tiene una funci√≥n pero si se busca que cada trabajo tengan m√°s funcionalidades o tener m√°s de estos trabajos iniciales, ser√° mucho m√°s f√°cil de mantener.

Ubicaci√≥n: `src/Ejercicio3/`

![Diagrama UML 3](./src/Ejercicio3/Ejercicio3.svg)

### [Ejercicio 4:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio4/sinaplicar) Sistema de Archivos

* Identifique por qu√© en este dise√±o se violan los principios SOLID DIP (Principio de Inversi√≥n de Dependencias) y OCP (Principio Open / Closed)

‚ùì Se violan los principios porque cada que se quiere agregar un nuevo tipo de archivo se debe modificar directamente la clase de gestor de archivos, generando m√°s if's anidados. 
Agregando que todo depende de un solo archivo que es la clase gestor de archivos.

* Qu√© otros principios crees que no se est√°n aplicando

‚ö†Ô∏è SRP: Ya que como se hab√≠a dicho anteriormente, la clase gestor de archivos tiene toda la responsabilidad para cualquier tipo de archivo.

* Proponga una soluci√≥n basada en interfaces aplicando los principios DIP y OCP

üí° Crear una interfaz de Gestor de Archivos con las funcionalidades generales, y crear una clase para cada tipo de archivo que se vaya a manipular.

Ubicaci√≥n: `src/Ejercicio4/`

![Diagrama UML 4](./src/Ejercicio4/Ejercicio4.svg)

### [Ejercicio 5:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio5/sinaplicar) Dispositivos 

* ¬øQu√© problemas visualiza en el dise√±o original?

‚ö†Ô∏è Se tiene una interfaz de dispositivos que tiene m√©todos que no todos los dispositivos no pueden implementar, como por ejemplo un reproductor mp3 no puede reproducir videos, lo cual en este c√≥digo se permite, o un mp4 (reproductor de video) no puede reproducir audio solamente.

* Proponga una soluci√≥n aplicando el principio de Segregaci√≥n de Interfaces (ISP)

üí° Se crean 3 interfaces m√°s espec√≠ficas todav√≠a, una para dispositivos, y otra para reproductores de audio y otra para video, despu√©s se agregan las clases de los dispositivos que implementen la clase dispositivo y su interfaz espec√≠fica.

Ubicaci√≥n: `src/Ejercicio5/`

![Diagrama UML 5](./src/Ejercicio5/Ejercicio5.svg)

### [Ejercicio 6:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio6/sinaplicar) Pedidos

* ¬øQu√© problemas visualiza en el dise√±o actual?

‚ö†Ô∏è El controlador tiene la responsabilidad de calcular el total del pedido, lo cual no le corresponde ya que debe coordinar la l√≥gica entre clases m√°s no las reglas del negocio.

* ¬øQu√© clase deber√≠a tener la responsabilidad de calcular el total?

‚ùì La clase pedido es la que deber√≠a de tener la responsabilidad de calcular dicho total, ya que es la que tiene toda la informaci√≥n necesaria para realizarlo.

* ¬øQu√© principios GRASP o SOLID aplicar√≠a para mejorar el dise√±o?

üí° Principios Utilizados:
- Information Expert: La clase Pedido tiene la informaci√≥n necesaria para calcular el total.
- SRP: Cada clase tiene una √∫nica responsabilidad.
- High Cohesion: Pedido es el que debe mantener la l√≥gica de negocio relacionada con los pedidos.
- Low Coupling: El controlador solo coordina las acciones de las clases sin involucrarse en la l√≥gica de negocio.

Ubicaci√≥n: `src/Ejercicio6/`

![Diagrama UML 6](./src/Ejercicio6/Ejercicio6.svg)

### [Ejercicio 7:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio7/sinaplicar) Reservas

* Identifique 3 problemas en el dise√±o del c√≥digo

‚ö†Ô∏è Problemas identificados:
1. La clase `Reserva` tiene m√∫ltiples responsabilidades (SRP).
2. Depende directamente de `DatabaseManager` y `EmailService`, violando **DIP**.
3. No hay una capa de control clara que organice la l√≥gica de negocio.

* ¬øC√≥mo podr√≠a usarse el principio Controller de GRASP en este problema?

‚ùì Se podr√≠a usar un controlador que simplemente maneje las solicitudes de reserva utilizando las clases especializadas para agregar a la base de datos, enviar una notificaci√≥n.

* Aplique el principio de Inversi√≥n de Dependencias para mejorar el c√≥digo

üí° Se agrega un repositorio con las funcionalidades de la reserva en este caso guardar, que la implementa DatabaseManager, y llamarlo desde el controlador.
Tambi√©n se agrega un servicio de notificaciones en caso de que se quiera tener varias maneras de notificar, que lo implementa la notificaci√≥n de email.


El objetivo es que reserva no dependa de detalles concretos, sino de abstracciones.


Ubicaci√≥n: `src/Ejercicio7/`

![Diagrama UML 7](./src/Ejercicio7/Ejercicio7.svg)

### [Ejercicio 8:](https://github.com/juliandhoyos14/EjerciciosPOO/tree/master/src/main/java/org/tallerprincipios/ejercicio8/sinaplicar) Sistema de Logging

* ¬øQu√© principio GRASP podr√≠a usarse para reducir el acoplamiento?

üí° Se podr√≠a usar Polimorfismo y el principio Dependency Inversion creando una interfaz `Logger` con los m√©todos `debug()` y `error()`. 
Para permitir que Service utilice cualquier implementaci√≥n de logger sin depender de detalles concretos, que aunque de momento solo tenemos loggers especificos como database, file y console, pueden ser m√°s o pueden tener funcionalidades diferentes seg√∫n la necesidad.

Ubicaci√≥n: `src/Ejercicio8/`

![Diagrama UML 8](./src/Ejercicio8/Ejercicio8.svg)

### **_Mapa Mental GRASP, SOLID, YAGNI, KISS, LoD y DRY_**

Ubicaci√≥n: `src/resources/MapaMental.svg`

![Mapa Mental](./src/resources/MapaMental.svg)

